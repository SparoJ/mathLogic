package com.sparo.test.review.sort;

import com.sparo.util.Utils;

/**
 * description: 插入排序 ？代表生疏度
 *
 * 什么是插入排序？
 * 左侧为有序序列，右侧为无序，起始左有序序列元素个数为1（0脚标），
 * 右侧每来一个数则同左侧的有序序列的元素从后向前依次比较，直至大小顺序固定
 *
 * 如何优化插入排序？？？？？
 * 可记录当前插入的元素值，左侧序列因为有序可让左侧元素依次向后（右）移，直至找到要插入的位置
 * 然后将要插入的元素放置到该位置
 *
 * 插入排序的时间空间复杂度？
 * n*n / 原地 o(1)
 *
 * 插入排序是否是稳定排序？
 * 稳定：左右元素移动
 * 插入排序的进化排序算法？？？？？
 * Created by sdh on 2020-03-02
 */
public class TestSortSerialInsert {


    public static int count = 0;
    public static void main(String[] args) {
        int[] arr = {3, 3, 6, 7, 4, 3, 9, 10, 2, 3, 1, 5, 0, 8};

        TestSortSerialInsert tssi = new TestSortSerialInsert();

//        tssi.insertSortOriginal(arr); // ？？？
//        System.out.println("count->" + count); // 91

//        tssi.insertSortOptimize(arr); // ？？？？？
//        tssi.shellSort(arr);
        tssi.shellNew(arr);
        System.out.println("count->" + count);
        Utils.printIntArray(arr);

    }

    private int getLength(int[] nums) {
        return nums.length;
    }

    /**
     *
     * note: 1. 内外循环表达的含义 2.需要几个变量来记录数据，分别代表什么含义,不记录会怎样？
     * 3.如何比较，谁和谁比较 4.当前要插入什么位置的值如何确认？5.完成一次插入后的最终赋值
     * @param nums
     */
    private void insertSortOptimize(int[] nums) {
        int length = getLength(nums);
        for(int i = 1; i<length; i++) {
            //初始化最后需要插入的元素值 这里不能只标记脚标，因为从后向前比较后数据可能移动
            int insertVal = nums[i];
            int insertIndex = i;
            for(int j = i; j>0; j--) {
                //比较的对象不对 是比较插入的值和有序序列的每一个元素
                if(nums[j-1]>insertVal) {
//                if(nums[j-1]<insertVal) { 大的在后面而不是 小的在后面！！！
                    nums[j] = nums[j-1];
                    insertIndex = j-1;
                }
                count++;
            }
            nums[insertIndex] = insertVal;
        }
    }


    private void insertSortOriginal(int[] arr) {
        int length = getLength(arr);
        //对应拿来去比较的元素起始脚标，从1 到 n-1
        for(int i = 1; i <length; i++) {
//            int tempVal = Integer.MIN_VALUE;
            //具体比较的元素范围，脚标从i开始到0位置，小则交换否则不用交换
            for(int j = i; j>0 ; j--) {
                if(arr[j]<arr[j-1]) {
                    Utils.swap(arr, j, j-1);
                }
                count++;
            }
        }
    }

    // int[] arr = {3, 3, 6, 7, 4, 3, 9, 10, 2, 3, 1, 5, 0, 8};
    /**
     * step步长->7->j插入元素位置->7->插入元素值nums[j]->10->插入元素相邻元素值nums[j-step]->3
     * 每次完成元素插入后的数组->->->->
     * 3->3->6->7->4->3->9->10->2->3->1->5->0->8------------------------
     * step步长->7->j插入元素位置->8->插入元素值nums[j]->2->插入元素相邻元素值nums[j-step]->3
     * 每次完成元素插入后的数组->->->->
     * 3->2->6->7->4->3->9->10->3->3->1->5->0->8------------------------
     * step步长->7->j插入元素位置->9->插入元素值nums[j]->3->插入元素相邻元素值nums[j-step]->6
     * 每次完成元素插入后的数组->->->->
     * 3->2->3->7->4->3->9->10->3->6->1->5->0->8------------------------
     * step步长->7->j插入元素位置->10->插入元素值nums[j]->1->插入元素相邻元素值nums[j-step]->7
     * 每次完成元素插入后的数组->->->->
     * 3->2->3->1->4->3->9->10->3->6->7->5->0->8------------------------
     * step步长->7->j插入元素位置->11->插入元素值nums[j]->5->插入元素相邻元素值nums[j-step]->4
     * 每次完成元素插入后的数组->->->->
     * 3->2->3->1->4->3->9->10->3->6->7->5->0->8------------------------
     * step步长->7->j插入元素位置->12->插入元素值nums[j]->0->插入元素相邻元素值nums[j-step]->3
     * 每次完成元素插入后的数组->->->->
     * 3->2->3->1->4->0->9->10->3->6->7->5->3->8------------------------
     * step步长->7->j插入元素位置->13->插入元素值nums[j]->8->插入元素相邻元素值nums[j-step]->9
     * 每次完成元素插入后的数组->->->->
     * 3->2->3->1->4->0->8->10->3->6->7->5->3->9------------------------
     * 完成一个gap步宽后的数组->->->->
     * 3->2->3->1->4->0->8->10->3->6->7->5->3->9------------------------
     * step步长->3->j插入元素位置->3->插入元素值nums[j]->1->插入元素相邻元素值nums[j-step]->3
     * 每次完成元素插入后的数组->->->->
     * 1->2->3->3->4->0->8->10->3->6->7->5->3->9------------------------
     * step步长->3->j插入元素位置->4->插入元素值nums[j]->4->插入元素相邻元素值nums[j-step]->2
     * 每次完成元素插入后的数组->->->->
     * 1->2->3->3->4->0->8->10->3->6->7->5->3->9------------------------
     * step步长->3->j插入元素位置->5->插入元素值nums[j]->0->插入元素相邻元素值nums[j-step]->3
     * 每次完成元素插入后的数组->->->->
     * 1->2->0->3->4->3->8->10->3->6->7->5->3->9------------------------
     * step步长->3->j插入元素位置->6->插入元素值nums[j]->8->插入元素相邻元素值nums[j-step]->3
     * 每次完成元素插入后的数组->->->->
     * 1->2->0->3->4->3->8->10->3->6->7->5->3->9------------------------
     * step步长->3->j插入元素位置->7->插入元素值nums[j]->10->插入元素相邻元素值nums[j-step]->4
     * 每次完成元素插入后的数组->->->->
     * 1->2->0->3->4->3->8->10->3->6->7->5->3->9------------------------
     * step步长->3->j插入元素位置->8->插入元素值nums[j]->3->插入元素相邻元素值nums[j-step]->3
     * 每次完成元素插入后的数组->->->->
     * 1->2->0->3->4->3->8->10->3->6->7->5->3->9------------------------
     * step步长->3->j插入元素位置->9->插入元素值nums[j]->6->插入元素相邻元素值nums[j-step]->8
     * 每次完成元素插入后的数组->->->->
     * 1->2->0->3->4->3->6->10->3->8->7->5->3->9------------------------
     * step步长->3->j插入元素位置->10->插入元素值nums[j]->7->插入元素相邻元素值nums[j-step]->10
     * 每次完成元素插入后的数组->->->->
     * 1->2->0->3->4->3->6->7->3->8->10->5->3->9------------------------
     * step步长->3->j插入元素位置->11->插入元素值nums[j]->5->插入元素相邻元素值nums[j-step]->3
     * 每次完成元素插入后的数组->->->->
     * 1->2->0->3->4->3->6->7->3->8->10->5->3->9------------------------
     * step步长->3->j插入元素位置->12->插入元素值nums[j]->3->插入元素相邻元素值nums[j-step]->8
     * 每次完成元素插入后的数组->->->->
     * 1->2->0->3->4->3->3->7->3->6->10->5->8->9------------------------
     * step步长->3->j插入元素位置->13->插入元素值nums[j]->9->插入元素相邻元素值nums[j-step]->10
     * 每次完成元素插入后的数组->->->->
     * 1->2->0->3->4->3->3->7->3->6->9->5->8->10------------------------
     * 完成一个gap步宽后的数组->->->->
     * 1->2->0->3->4->3->3->7->3->6->9->5->8->10------------------------
     * step步长->1->j插入元素位置->1->插入元素值nums[j]->2->插入元素相邻元素值nums[j-step]->1
     * 每次完成元素插入后的数组->->->->
     * 1->2->0->3->4->3->3->7->3->6->9->5->8->10------------------------
     * step步长->1->j插入元素位置->2->插入元素值nums[j]->0->插入元素相邻元素值nums[j-step]->2
     * 每次完成元素插入后的数组->->->->
     * 0->1->2->3->4->3->3->7->3->6->9->5->8->10------------------------
     * step步长->1->j插入元素位置->3->插入元素值nums[j]->3->插入元素相邻元素值nums[j-step]->2
     * 每次完成元素插入后的数组->->->->
     * 0->1->2->3->4->3->3->7->3->6->9->5->8->10------------------------
     * step步长->1->j插入元素位置->4->插入元素值nums[j]->4->插入元素相邻元素值nums[j-step]->3
     * 每次完成元素插入后的数组->->->->
     * 0->1->2->3->4->3->3->7->3->6->9->5->8->10------------------------
     * step步长->1->j插入元素位置->5->插入元素值nums[j]->3->插入元素相邻元素值nums[j-step]->4
     * 每次完成元素插入后的数组->->->->
     * 0->1->2->3->3->4->3->7->3->6->9->5->8->10------------------------
     * step步长->1->j插入元素位置->6->插入元素值nums[j]->3->插入元素相邻元素值nums[j-step]->4
     * 每次完成元素插入后的数组->->->->
     * 0->1->2->3->3->3->4->7->3->6->9->5->8->10------------------------
     * step步长->1->j插入元素位置->7->插入元素值nums[j]->7->插入元素相邻元素值nums[j-step]->4
     * 每次完成元素插入后的数组->->->->
     * 0->1->2->3->3->3->4->7->3->6->9->5->8->10------------------------
     * step步长->1->j插入元素位置->8->插入元素值nums[j]->3->插入元素相邻元素值nums[j-step]->7
     * 每次完成元素插入后的数组->->->->
     * 0->1->2->3->3->3->3->4->7->6->9->5->8->10------------------------
     * step步长->1->j插入元素位置->9->插入元素值nums[j]->6->插入元素相邻元素值nums[j-step]->7
     * 每次完成元素插入后的数组->->->->
     * 0->1->2->3->3->3->3->4->6->7->9->5->8->10------------------------
     * step步长->1->j插入元素位置->10->插入元素值nums[j]->9->插入元素相邻元素值nums[j-step]->7
     * 每次完成元素插入后的数组->->->->
     * 0->1->2->3->3->3->3->4->6->7->9->5->8->10------------------------
     * step步长->1->j插入元素位置->11->插入元素值nums[j]->5->插入元素相邻元素值nums[j-step]->9
     * 每次完成元素插入后的数组->->->->
     * 0->1->2->3->3->3->3->4->5->6->7->9->8->10------------------------
     * step步长->1->j插入元素位置->12->插入元素值nums[j]->8->插入元素相邻元素值nums[j-step]->9
     * 每次完成元素插入后的数组->->->->
     * 0->1->2->3->3->3->3->4->5->6->7->8->9->10------------------------
     * step步长->1->j插入元素位置->13->插入元素值nums[j]->10->插入元素相邻元素值nums[j-step]->9
     * 每次完成元素插入后的数组->->->->
     * 0->1->2->3->3->3->3->4->5->6->7->8->9->10------------------------
     * 完成一个gap步宽后的数组->->->->
     * 0->1->2->3->3->3->3->4->5->6->7->8->9->10------------------------
     */
    /**
     * 插入排序优化终版 希尔排序
     */

    public void shellSort(int[] nums) {
        //获取数组的长度
        int length = getLength(nums);
        //每次循环时 gap 步长减为之前一半
        for(int gap = length/2; gap>0; gap/=2) {
            //主逻辑：插入排序逻辑 从后向前，定位当前要插入的元素，得到最后要插入的位置并插入符合排序条件的值
            //按照当前gap步长算要插入的次数 从第一次要插入的位置开始 每次移动一个位置向后 -> 内层
            for(int i= gap; i<length; i++) {

                int j = i;
                int temp = nums[j];
                //从后向前 比较的是temp和前面的元素
                System.out.println("step步长->" + gap + "->j插入元素位置->" + j + "->插入元素值nums[j]->"
                        + nums[j] + "->插入元素相邻元素值nums[j-step]->" +nums[j-gap]);
                while((j-gap)>=0&& nums[j-gap]>temp) {
                    nums[j] = nums[j-gap];
                    j = j-gap;
                }
                //将需要插入的元素插入到指定的位置
                nums[j] = temp;
                System.out.println("每次完成元素插入后的数组->->->->");
                Utils.printIntArray(nums);
            }
            //完成一个gap 后的nums数组
            System.out.println("完成一个gap步宽后的数组->->->->");
            Utils.printIntArray(nums);
        }
    }



    public void shellNew(int[] nums) {
        int length = nums.length;
        for(int gap = length>>1; gap>0; gap=(gap>>1)) {

            for(int i = gap; i<length; i++) {
                int j = i;
                int temp = nums[j];
                while(j-gap>=0&& nums[j-gap]>temp) {
                    nums[j] = nums[j-gap];
                    j= j-gap;
                }
                nums[j] = temp;
            }
        }
    }



}
